#include "../Windrews.hpp"

static const char* TEXTURE_VERTEX_SHADER_PATH = "./shaders/textures.vs";
static const char* TEXTURE_FRAG_SHADER_PATH = "./shaders/textures.frag";
static const char* PRIMITIVE_VERTEX_SHADER_PATH = "./shaders/primitive.vs";
static const char* PRIMITIVE_FRAG_SHADER_PATH = "./shaders/primitive.frag";

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////UTILITIES IMPLEMENTATION////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
Point NORMAL_TO_PIXELS(const Point& other, const viewPortState& state) {
	return Point(int((other.x + 1) * double(state.width) / double(2)), int((other.y + 1) * double(state.height) / double(2)));
}

Point PIXELS_TO_NORMAL(const Point& other, const viewPortState& state) {
	return Point((double(2 * other.x) / double(state.width)) - 1, (double(2 * other.y) / double(state.height)) - 1);
}

void windrewsViewPort(const viewPortState& state) {
	glViewport(state.x, state.y, state.width, state.height);
}

void windrewsViewPort(int x, int y, int width, int height) {
	glViewport(x, y, width, height);
}

Point mouseToMiddle(const Point& point, viewPortState state) {
	Point ans;
	ans.x = 2 * point.x / state.width - 1.0;
	ans.y = 2 * point.y / state.height - 1.0;
	return ans;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////INIT IMPLEMENTATION////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
GLFWwindow* initCreateContextWindow(int argc, char** argv, int heigth, int width) {
	GLFWwindow* window;

	if (!glfwInit()) {
		std::cerr << "Failed to initialize GLFW" << std::endl;
		return nullptr;
	}

	glutInit(&argc, argv);

	glfwWindowHint(GLFW_SAMPLES, 16);
	window = glfwCreateWindow(width, heigth, "Graphics", NULL, NULL);

	if (!window)
	{
		glfwTerminate();
		return nullptr;
	}

	glfwMakeContextCurrent(window);

	glewExperimental = GL_TRUE;
	if (glewInit() != GLEW_OK)
	{
		std::cerr << "Failed to initialize GLEW" << std::endl;
		return nullptr;
	}

	return window;
}

Windrew* windrewsInit(int argc, char** argv, Color color, int heigth, int width) {
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

	GLFWwindow* window = initCreateContextWindow(argc, argv, heigth, width);
	if (window == nullptr)
		return nullptr;

	glfwSetInputMode(window, GLFW_STICKY_MOUSE_BUTTONS, GLFW_TRUE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	GLFWcursor* cursor = glfwCreateStandardCursor(GLFW_CROSSHAIR_CURSOR);

	glfwSetCursor(window, cursor);

	return new Windrew (window, color, heigth, width);
}

void windrewsTerminate() {
	glfwTerminate();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////SHADERS IMPLEMENTATION////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
Shaders::Shaders(const char* textureVs, const char* textureFrag, const char* primVs, const char* primFrag):
	textureShader(textureVs, textureFrag),
	primitiveShader(primVs, primFrag)
	{}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////WINDREW IMPLEMENTATION///////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////


	Windrew::Windrew(GLFWwindow* window, Color color, int heigth, int width): 
	WindowsTree(window, color, heigth, width), 
	events(window, heigth, width),
	shaders(TEXTURE_VERTEX_SHADER_PATH, TEXTURE_FRAG_SHADER_PATH, PRIMITIVE_VERTEX_SHADER_PATH, PRIMITIVE_FRAG_SHADER_PATH) {
		viewPorts.emplace(0, 0, width, heigth);
	}
	
	Windrew::~Windrew () = default;

	bool Windrew::shouldClose() {
		return glfwWindowShouldClose(main_window);
	}

	void Windrew::pollEvents() {
		glfwPollEvents();
		WindowStat status = events.getEvent();
		for (auto w: UnderWindows)
			w->pollEvents(status);
	}

	Point Windrew::getStartPoint() {
		return startPoint;
	}

	void Windrew::draw () {
		glViewport(0, 0, screen_width, screen_height);
		bg_color.set_as_bg ();
		for (auto& w: UnderWindows)
			w->draw (shaders);
		glfwSwapBuffers(main_window);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////EVENT MANAGER IMPLEMENTATION/////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
Point EventManager::getMousePos(GLFWwindow* window, int screen_heigth, int screen_width) {
	double x;
	double y;
	glfwGetCursorPos(window, &mousePos.x, &mousePos.y);
	return mousePos;
}

void EventManager::getKeys(GLFWwindow* window, int key, int scancode, int action, int mods) {
	keys.push({key, action});
}

void EventManager::getMouseKeys(GLFWwindow* window, int key, int action, int mods) {
	keys.push({key, action});
}

EventManager::EventManager(GLFWwindow* window, int screen_heigth, int screen_width):
window (window),
screen_heigth (screen_heigth),
screen_width (screen_width) {
	glfwSetKeyCallback(window, getKeys);
	glfwSetMouseButtonCallback(window, getMouseKeys);
}

WindowStat EventManager::getEvent() {
	WindowStat status;
	if (!keys.empty()){
		status.key = keys.front();
		keys.pop();
	}
	status.screen_height = screen_heigth;
	status.mousePos = getMousePos(window, screen_heigth, screen_width);
	return status;
}

std::queue<keyAction> EventManager::keys;
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////WINDOW STAT IMPLEMENTATION////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
Point WindowStat::getMousePos(const viewPortState& state) const {
	Point res = mousePos;
	res.y = screen_height - res.y;
	res.x -= state.x;
	res.y -= state.y;
	return mouseToMiddle(res, state);
}

keyAction WindowStat::getKeyAction() const {
	return key;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////VIEW PORT STATE IMPLEMENTATION///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
viewPortState::viewPortState(int x, int y, int width, int height):
	x(x),
	y(y),
	width(width),
	height(height)
	{}

viewPortState::viewPortState(const Point& point, int width, int height):
	x(point.x),
	y(point.y),
	width(width),
	height(height)
	{}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////POINT IMPLEMENTATION//////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
	Point::Point(double x, double y): x(x), y(y) {}	
	Point::Point() = default;
	Point::Point(const Point& other) = default;
	Point::Point(Point&& other) = default;
	Point& Point::operator=(const Point& other) = default;
	Point& Point::operator=(Point&&) = default;

	bool Point::operator<(const Point& other) const {
		if (x == other.x) {
			return y < other.y;
		}
		else {
			return x < other.x;
		}
	}

	Point& Point::operator+=(const Point& other) {
		this->x += other.x;
		this->y += other.y;
		return *this;
	} 

	Point Point::operator*(double k) const {
		Point ans;
		ans.x = k*x;
		ans.y = k*y;
		return ans;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////WINDOWS TREE IMPLEMENTATION///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
WindowsTree::WindowsTree (GLFWwindow* window, Color color, int screen_height, int screen_width): 
	main_window (window), 
	bg_color (color),
	screen_height (screen_height),
	screen_width (screen_width),
	startPoint (0, 0) {}

	WindowsTree::~WindowsTree () = default;

	void WindowsTree::move(const Point& moveVec) {
		startPoint += moveVec;
		for (auto w: UnderWindows)
			w->move(moveVec);
	}

	void WindowsTree::addViewPort(const viewPortState& state) {
		viewPorts.push(state);
	}

	viewPortState WindowsTree::getViewPort() {
		return viewPorts.top();
	}

	void WindowsTree::rmViewPort() {
		viewPorts.pop();
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////WINDOW NODE IMPLEMENTATION///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
	WindowNode::WindowNode(AbstractWindow* new_window, WindowsTree* new_main_window): 
	window (new_window), 
	main_window (new_main_window) {};
	
	void WindowNode::moveUnderWindows(const Point& moveVec) {
		for (auto w:UnderWindows)
			w->move(moveVec);
	}

	void WindowNode::move(const Point& moveVec) {
		window->move(moveVec, main_window->getViewPort());
		if (!window->changeViewPort())
			moveUnderWindows(moveVec);
	}

	void WindowNode::draw(const Shaders& shaders) {
		if (window->changeViewPort()) {
			main_window->addViewPort(window->getViewPortChange());
		}

		auto state = main_window->getViewPort();
		window->draw(state, shaders);
		for (auto w: UnderWindows)
			w->draw(shaders);

		if (window->changeViewPort()) {
			main_window->rmViewPort();
			windrewsViewPort(main_window->getViewPort());
		}
	}

	void WindowNode::pollEvents(const WindowStat& status) {
		if (window->changeViewPort()) {
			main_window->addViewPort(window->getViewPortChange());
		}

		auto state = main_window->getViewPort();
		window->callback(status, state);
		for (auto w: UnderWindows)
			w->pollEvents(status);

		if (window->changeViewPort()) {
			main_window->rmViewPort();
			windrewsViewPort(main_window->getViewPort());
		}
	}